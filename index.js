/// A prefix that uniquely identifies this plugin, prepended onto the name of any variable generated by this plugin.
const variablePrefix = 'maplibre_gl_dates';

/**
 * Filters the map’s features by a date.
 *
 * @param map The MapboxGL map object to filter the style of.
 * @param date The date to filter by.
 */
function filterByDate(map, date) {
  if (typeof date === 'string') {
    date = dateFromISODate(date);
  }
  let decimalYear = decimalYearFromDate(date);
  map.getStyle().layers.map(function (layer) {
    if (!('source-layer' in layer)) return;

    let filter = constrainFilterByDate(map.getFilter(layer.id), decimalYear);
    map.setFilter(layer.id, filter);
  });
}

/**
 * Converts the given date to a decimal year.
 *
 * @param date A date object.
 * @returns A floating point number of years since year 0.
 */
function decimalYearFromDate(date) {
  // Add the year and the fraction of the date between two New Year’s Days.
  let year = date.getUTCFullYear();
  let nextNewYear = dateFromUTC(year + 1, 0, 1).getTime();
  let lastNewYear = dateFromUTC(year, 0, 1).getTime();
  return year + (date.getTime() - lastNewYear) / (nextNewYear - lastNewYear);
}

/**
 * Converts the given ISO 8601-1 date to a `Date` object.
 *
 * @param isoDate A date string in ISO 8601-1 format.
 * @returns A date object.
 */
function dateFromISODate(isoDate) {
  // Require a valid YYYY, YYYY-MM, or YYYY-MM-DD date, but allow the year
  // to be a variable number of digits or negative, unlike ISO 8601-1.
  if (!isoDate || !/^-?\d{1,4}(?:-\d\d){0,2}$/.test(isoDate)) return;

  let ymd = isoDate.split('-');
  // A negative year results in an extra element at the beginning.
  if (ymd[0] === '') {
    ymd.shift();
    ymd[0] *= -1;
  }
  let year = +ymd[0];
  let date = dateFromUTC(year, +ymd[1] - 1, +ymd[2]);
  return !isNaN(date) && date;
}

/**
 * Returns a `Date` object representing the given UTC date components.
 *
 * @param year A one-based year in the proleptic Gregorian calendar.
 * @param month A zero-based month.
 * @param day A one-based day.
 * @returns A date object.
 */
function dateFromUTC(year, month, day) {
  let date = new Date(Date.UTC(year, month, day));
  // Date.UTC() treats a two-digit year as an offset from 1900.
  date.setUTCFullYear(year);
  return date;
}

/**
 * Returns a modified version of the given filter that only evaluates to
 * true if the feature coincides with the given decimal year.
 *
 * @param filter The original layer filter.
 * @param decimalYear The decimal year to filter by.
 * @returns A filter similar to the given filter, but with added conditions
 *	that require the feature to coincide with the decimal year.
 */
function constrainFilterByDate(filter, decimalYear) {
  if (typeof filter === 'undefined') {
    return;
  } else if (isLegacyFilter(filter)) {
    return constrainLegacyFilterByDate(filter, decimalYear);
  } else {
    return constrainExpressionFilterByDate(filter, decimalYear);
  }
}

/**
 * Returns a modified version of the given legacy filter that only evaluates to
 * true if the feature coincides with the given decimal year.
 *
 * @param filter The original layer filter using the legacy syntax.
 * @param decimalYear The decimal year to filter by.
 * @returns A filter similar to the given filter, but with added conditions
 *	that require the feature to coincide with the decimal year. If the filter
 *  previously been passed into this function, it surgically updates the filter.
 */
function constrainLegacyFilterByDate(filter, decimalYear) {
  if (filter[0] === 'all' && filter[1] && filter[1][0] === 'any') {
    if (filter[1][2] && filter[1][2][0] === '<=' && filter[1][2][1] === 'start_decdate') {
      filter[1][2][2] = decimalYear;
    }
    if (filter[2][2] && filter[2][2][0] === '>=' && filter[2][2][1] === 'end_decdate') {
      filter[2][2][2] = decimalYear;
    }
    return filter;
  }

  return [
    'all',
    [
      'any',
      ['!has', 'start_decdate'],
      ['<=', 'start_decdate', decimalYear]
    ],
    [
      'any',
      ['!has', 'end_decdate'],
      ['>=', 'end_decdate', decimalYear]
    ],
    filter,
  ];
}

/**
 * Returns a modified version of the given expression-based filter that only
 * evaluates to true if the feature coincides with the given decimal year.
 *
 * @param filter The original layer filter using the expression syntax.
 * @param decimalYear The decimal year to filter by.
 * @returns A filter similar to the given filter, but with added conditions
 *	that require the feature to coincide with the decimal year. If the filter
 *  previously been passed into this function, it merely updates a variable.
 */
function constrainExpressionFilterByDate(filter, decimalYear) {
  const decimalYearVariable = `${variablePrefix}__decimalYear`;
  if (filter[0] === 'let' && filter[1] === decimalYearVariable) {
    filter[2] = decimalYear;
    return filter;
  }

  let allExpression = [
    'all',
    [
      'any',
      ['!', ['has', 'start_decdate']],
      ['<=', ['get', 'start_decdate'], ['var', decimalYearVariable]]
    ],
    [
      'any',
      ['!', ['has', 'end_decdate']],
      ['>=', ['get', 'end_decdate'], ['var', decimalYearVariable]]
    ],
    filter,
  ];

  return [
    'let',
    decimalYearVariable, decimalYear,
    allExpression,
  ];
}

/**
 * Returns a Boolean indicating whether the given filter is definitely based on [the deprecated legacy filter syntax](https://maplibre.org/maplibre-style-spec/deprecations/#other-filter) and thus incompatible with an expression.
 *
 * @param filter A filter that is either based on the legacy syntax or an expression.
 * @returns True if the filter is definitely based on the legacy syntax; false if it might be an expression.
 */
function isLegacyFilter(filter) {
  if (!Array.isArray(filter) || filter.length < 2) {
    return false;
  }

  let args = filter.slice(1);
  switch (filter[0]) {
    case '!has':
    case '!in':
    case 'none':
      // These are filters but not expression operators.
      return true;

    case 'has':
      // These are unlikely feature properties but are built-in legacy keys.
      return args[0] === '$id' || args[0] === '$type';

    case 'in':
      return (// The legacy syntax includes all the possible matches inline.
              args.length > 2 ||
              // These are unlikely feature properties but are built-in legacy keys.
              args[0] === '$id' || args[0] === '$type' ||
              // The `in` expression only allows searching within a string or array.
              typeof args[1] === 'number' || typeof args[1] === 'boolean' ||
              // It would be pointless to search for a string literal inside another string literal.
              (typeof args[0] === 'string' && typeof args[1] === 'string'));

    case '==':
    case '!=':
    case '>':
    case '>=':
    case '<':
    case '<=':
      // An expression would require the string literal to be compared to another string literal, but it would be pointless to do so.
      return typeof args[0] === 'string' && !Array.isArray(args[1]);

    case 'all':
    case 'any':
      // If any of the arguments is definitely a legacy filter, the whole thing is too. 
      return args.some(isLegacyFilter);

    default:
      return false;
  }
}

if (typeof window !== 'undefined' && 'maplibregl' in window) {
  maplibregl.Map.prototype.filterByDate = function (date) {
    filterByDate(this, date);
  };
} else if (typeof module !== 'undefined') {
  module.exports = {
    filterByDate: filterByDate,
    decimalYearFromDate: decimalYearFromDate,
    dateFromISODate: dateFromISODate,
    constrainFilterByDate: constrainFilterByDate,
    constrainLegacyFilterByDate: constrainLegacyFilterByDate,
    constrainExpressionFilterByDate: constrainExpressionFilterByDate,
    isLegacyFilter: isLegacyFilter,
  };
}
